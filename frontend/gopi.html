<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chennai Routes Map</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
    
    <!-- Leaflet Routing Machine CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet-routing-machine/3.2.12/leaflet-routing-machine.css" />
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }
        
        #map {
            height: 100vh;
            width: 100%;
        }
        
        .controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            max-width: 320px;
            border: 1px solid #ccc;
        }
        
        .controls h3 {
            margin: 0 0 15px;
            color: #333;
            font-size: 1.2em;
        }
        
        .location-input {
            margin-bottom: 15px;
        }
        
        .location-input label {
            font-weight: bold;
            color: #555;
        }
        
        .location-input select {
            width: 100%;
            padding: 8px;
            margin-top: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
            background-color: #f9f9f9;
        }
        
        .buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }
        
        .button {
            padding: 8px 12px;
            background-color: #0078A8;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            flex: 1;
            text-align: center;
        }
        
        .button:hover {
            background-color: #005d85;
        }
        
        .button-secure {
            background-color: #4CAF50;
        }
        
        .button-secure:hover {
            background-color: #3e8e41;
        }
        
        .route-info {
            margin-top: 15px;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 3px;
            font-size: 0.9em;
            color: #666;
        }
        
        .legend {
            position: absolute;
            bottom: 30px;
            right: 10px;
            z-index: 1000;
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        }
        
        .legend-item {
            margin-bottom: 5px;
            display: flex;
            align-items: center;
        }
        
        .legend-color {
            width: 20px;
            height: 5px;
            margin-right: 8px;
            display: inline-block;
        }
        
        .legend-marker {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            display: inline-block;
        }
        
        .danger-areas {
            margin-top: 15px;
            border-top: 1px solid #ddd;
            padding-top: 10px;
        }
        
        .danger-areas h4 {
            margin: 0 0 10px;
            cursor: pointer;
            color: #0078A8;
        }
        
        .danger-area {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
        }
        
        .danger-area label {
            margin-left: 5px;
            color: #444;
        }
        
        .weather-info {
            margin-top: 15px;
            font-size: 0.9em;
            color: #777;
            border-top: 1px solid #ddd;
            padding-top: 10px;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="controls">
        <h3>Chennai Route Finder</h3>
        
        <div class="location-input">
            <label for="start">Start Location:</label>
            <select id="start"></select>
        </div>
        
        <div class="location-input">
            <label for="end">End Location:</label>
            <select id="end"></select>
        </div>
        
        <div class="location-input">
            <label for="travelMode">Travel Mode:</label>
            <select id="travelMode">
                <option value="car">Car</option>
                <option value="walk">Walking</option>
                <option value="bike">Bicycle</option>
            </select>
        </div>
        
        <div class="danger-areas">
            <h4 onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'none' ? 'block' : 'none'">Avoid Areas</h4>
            <div>
                <div class="danger-area">
                    <input type="checkbox" id="area1" checked>
                    <label for="area1">High Crime Areas</label>
                </div>
                <div class="danger-area">
                    <input type="checkbox" id="area2" checked>
                    <label for="area2">Flood-Prone Areas</label>
                </div>
                <div class="danger-area">
                    <input type="checkbox" id="area3" checked>
                    <label for="area3">Heavy Traffic Areas</label>
                </div>
            </div>
        </div>
        
        <div class="buttons">
            <button id="findShortest" class="button">Find Shortest Route (A*)</button>
            <button id="findSecure" class="button button-secure">Find Secure Route</button>
            <button id="toggleTraffic" class="button">Toggle Traffic</button>
            <button id="exportRoute" class="button">Export Route</button>
            <button id="clearRoutes" class="button">Clear</button>
        </div>
        
        <div class="route-info" id="routeInfo">
            Select start and end locations, then click a button to find a route.
        </div>
        
        <div class="weather-info" id="weatherInfo">
            Loading weather information...
        </div>
    </div>
    
    <div class="legend">
        <h4>Map Legend</h4>
        <div class="legend-item">
            <span class="legend-color" style="background-color: #0078A8;"></span>
            <span>Shortest Route (A*)</span>
        </div>
        <div class="legend-item">
            <span class="legend-color" style="background-color: #4CAF50;"></span>
            <span>Secure Route</span>
        </div>
        <div class="legend-item">
            <span class="legend-marker" style="background-color: #FF6B6B;"></span>
            <span>High Crime Area</span>
        </div>
        <div class="legend-item">
            <span class="legend-marker" style="background-color: #4D96FF;"></span>
            <span>Flood-Prone Area</span>
        </div>
        <div class="legend-item">
            <span class="legend-marker" style="background-color: #FFD166;"></span>
            <span>Heavy Traffic Area</span>
        </div>
    </div>
    
    <!-- Leaflet JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    
    <!-- Leaflet Routing Machine JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-routing-machine/3.2.12/leaflet-routing-machine.min.js"></script>
    
    <script>
        // Initialize the map centered on Chennai
        const map = L.map('map').setView([13.0827, 80.2707], 12);
        
        // Add OpenStreetMap tiles
        const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);
        
        // Add traffic layer
        const trafficLayer = L.tileLayer('https://{s}.tile.opentraffic.io/{z}/{x}/{y}.png', {
            attribution: '© OpenTraffic',
            opacity: 0.7
        });
        let trafficVisible = false;
        
        // Variables to store route controls
        let shortestRouteControl = null;
        let secureRouteControl = null;
        
        // Chennai points of interest and coordinates with categories
        const chennaiLocations = {
            "Residential": {
                "Anna Nagar": [13.0850, 80.2101],
                "Velachery": [12.9815, 80.2176],
                "Adyar": [13.0012, 80.2565],
                "Besant Nagar": [13.0002, 80.2668],
                "Mylapore": [13.0336, 80.2687],
                "Kodambakkam": [13.0510, 80.2272],
                "Kilpauk": [13.0833, 80.2417],
                "Nungambakkam": [13.0569, 80.2425],
                "West Mambalam": [13.0411, 80.2175],
                "Alwarpet": [13.0324, 80.2568],
                "Mandaveli": [13.0229, 80.2664],
                "Purasawalkam": [13.0885, 80.2470],
                "Chetpet": [13.0713, 80.2440],
                "Thiruvanmiyur": [12.9827, 80.2590],
                "Mogappair": [13.0958, 80.1712],
                "Valasaravakkam": [13.0428, 80.1862],
                "Virugambakkam": [13.0543, 80.1968],
                "Kolathur": [13.1227, 80.2265],
                "Medavakkam": [12.9243, 80.1924],
                "Nanganallur": [12.9853, 80.1924]
            },
            "Commercial": {
                "T Nagar": [13.0410, 80.2339],
                "Sowcarpet": [13.0927, 80.2786],
                "George Town": [13.0921, 80.2864],
                "Mount Road": [13.0628, 80.2416],
                "OMR Road": [12.9512, 80.2322],
                "DLF IT Park": [12.9879, 80.2482],
                "Tidel Park": [12.9896, 80.2486]
            },
            "Transport": {
                "Chennai Central": [13.0827, 80.2707],
                "Chennai Airport": [12.9941, 80.1709],
                "Chennai Central Bus Station": [13.0819, 80.2755],
                "Koyambedu Bus Terminal": [13.0693, 80.1937],
                "Egmore": [13.0732, 80.2608]
            },
            "Industrial": {
                "Ambattur": [13.1143, 80.1548],
                "Guindy": [13.0067, 80.2206],
                "Padi": [13.1037, 80.1914],
                "Sriperumbudur": [12.9682, 79.9493]
            },
            "Suburban": {
                "Porur": [13.0374, 80.1575],
                "Tambaram": [12.9249, 80.1000],
                "Chromepet": [12.9516, 80.1462],
                "Sholinganallur": [12.9010, 80.2279],
                "Pallavaram": [12.9675, 80.1491],
                "Perungudi": [12.9531, 80.2425],
                "Thoraipakkam": [12.9242, 80.2298],
                "Avadi": [13.1067, 80.1019],
                "Poonamallee": [13.0466, 80.1173],
                "Red Hills": [13.1927, 80.1841],
                "Selaiyur": [12.9144, 80.1402],
                "Vandalur": [12.8928, 80.0822],
                "Kelambakkam": [12.7782, 80.2203],
                "Siruseri": [12.8210, 80.2295],
                "Madhavaram": [13.1487, 80.2311],
                "Pallikaranai": [12.9390, 80.2101]
            },
            "Historical": {
                "Triplicane": [13.0569, 80.2711],
                "Chintadripet": [13.0735, 80.2718],
                "Royapettah": [13.0578, 80.2597],
                "Choolai": [13.0967, 80.2636],
                "Park Town": [13.0805, 80.2764]
            },
            "Beach": {
                "Marina Beach": [13.0500, 80.2824],
                "ECR Road": [12.9984, 80.2643],
                "Kovalam Beach": [12.7894, 80.2553]
            },
            "Other": {
                "Vadapalani": [13.0519, 80.2121],
                "Saidapet": [13.0226, 80.2209],
                "Washermanpet": [13.1171, 80.2893],
                "Tondiarpet": [13.1285, 80.2839],
                "Royapuram": [13.1088, 80.2996],
                "Kotturpuram": [13.0169, 80.2428],
                "Perambur": [13.1164, 80.2339],
                "IIT Madras": [12.9914, 80.2336],
                "MRC Nagar": [13.0172, 80.2771],
                "Ramapuram": [13.0306, 80.1843]
            }
        };
        
        // Populate dropdowns with categorized locations
        const startSelect = document.getElementById('start');
        const endSelect = document.getElementById('end');
        for (const category in chennaiLocations) {
            const optgroup = document.createElement('optgroup');
            optgroup.label = category;
            for (const location in chennaiLocations[category]) {
                const option = document.createElement('option');
                option.value = location;
                option.text = location;
                optgroup.appendChild(option);
            }
            startSelect.appendChild(optgroup.cloneNode(true));
            endSelect.appendChild(optgroup);
        }
        startSelect.value = "Chennai Central";
        endSelect.value = "Chennai Airport";
        
        // Define danger areas in Chennai (Expanded List)
        const dangerAreas = {
            highCrime: [
                { name: "Washermanpet", coords: [13.1171, 80.2893], radius: 1000 },
                { name: "Royapuram", coords: [13.1088, 80.2996], radius: 800 },
                { name: "Pulianthope", coords: [13.1041, 80.2606], radius: 1200 },
                { name: "Vyasarpadi", coords: [13.1184, 80.2517], radius: 900 },
                { name: "Otteri", coords: [13.0946, 80.2511], radius: 850 },
                { name: "Perambur", coords: [13.1164, 80.2339], radius: 750 }
            ],
            floodProne: [
                { name: "Velachery", coords: [12.9815, 80.2176], radius: 1500 },
                { name: "Mudichur", coords: [12.9138, 80.0686], radius: 1200 },
                { name: "Tambaram", coords: [12.9249, 80.1000], radius: 1000 },
                { name: "Pulianthope", coords: [13.1041, 80.2606], radius: 900 },
                { name: "Pallikaranai", coords: [12.9390, 80.2101], radius: 1800 },
                { name: "Perungudi", coords: [12.9531, 80.2425], radius: 1200 },
                { name: "Semmancheri", coords: [12.8735, 80.2279], radius: 1100 },
                { name: "Madipakkam", coords: [12.9572, 80.1983], radius: 1300 }
            ],
            heavyTraffic: [
                { name: "T Nagar", coords: [13.0410, 80.2339], radius: 800 },
                { name: "Guindy", coords: [13.0067, 80.2206], radius: 1000 },
                { name: "Koyambedu", coords: [13.0698, 80.1947], radius: 900 },
                { name: "Poonamallee High Road", coords: [13.0709, 80.2228], radius: 700 },
                { name: "Anna Salai", coords: [13.0628, 80.2416], radius: 1100 },
                { name: "OMR Junction", coords: [12.9512, 80.2322], radius: 950 },
                { name: "Kathipara Junction", coords: [13.0079, 80.2025], radius: 800 },
                { name: "Vadapalani", coords: [13.0519, 80.2121], radius: 750 },
                { name: "Chromepet", coords: [12.9516, 80.1462], radius: 700 }
            ]
        };
        
        // Add danger areas to the map
        function addDangerAreasToMap() {
            dangerAreas.highCrime.forEach(area => {
                L.circle(area.coords, {
                    color: '#FF6B6B',
                    fillColor: '#FF6B6B',
                    fillOpacity: 0.2,
                    radius: area.radius
                }).bindPopup(High Crime Area: ${area.name}).addTo(map);
            });
            
            dangerAreas.floodProne.forEach(area => {
                L.circle(area.coords, {
                    color: '#4D96FF',
                    fillColor: '#4D96FF',
                    fillOpacity: 0.2,
                    radius: area.radius
                }).bindPopup(Flood-Prone Area: ${area.name}).addTo(map);
            });
            
            dangerAreas.heavyTraffic.forEach(area => {
                L.circle(area.coords, {
                    color: '#FFD166',
                    fillColor: '#FFD166',
                    fillOpacity: 0.2,
                    radius: area.radius
                }).bindPopup(Heavy Traffic Area: ${area.name}).addTo(map);
            });
        }
        addDangerAreasToMap();
        
        // Function to get coordinates from location name
        function getCoordinates(locationName) {
            for (const category in chennaiLocations) {
                if (chennaiLocations[category][locationName]) {
                    return chennaiLocations[category][locationName];
                }
            }
            return chennaiLocations["Transport"]["Chennai Central"];
        }
        
        // Haversine distance formula
        function getDistance(coord1, coord2) {
            const R = 6371; // Radius of the Earth in km
            const dLat = (coord2[0] - coord1[0]) * Math.PI / 180;
            const dLon = (coord2[1] - coord1[1]) * Math.PI / 180;
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(coord1[0] * Math.PI / 180) * Math.cos(coord2[0] * Math.PI / 180) * 
                Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        // A* Algorithm Implementation (Optimized for Time)
        function aStarAlgorithm(start, end, dangerPoints) {
            const gridSize = 0.005; // approx 500m grid cells
            const bounds = {
                minLat: 12.8,
                maxLat: 13.3,
                minLng: 80.0,
                maxLng: 80.4
            };
            
            const latCells = Math.ceil((bounds.maxLat - bounds.minLat) / gridSize);
            const lngCells = Math.ceil((bounds.maxLng - bounds.minLng) / gridSize);
            
            const grid = [];
            for (let i = 0; i < latCells; i++) {
                grid[i] = [];
                for (let j = 0; j < lngCells; j++) {
                    grid[i][j] = 1; // Base cost
                }
            }
            
            dangerPoints.forEach(point => {
                const latIdx = Math.floor((point.coords[0] - bounds.minLat) / gridSize);
                const lngIdx = Math.floor((point.coords[1] - bounds.minLng) / gridSize);
                
                const cellRadius = Math.ceil(point.radius / 1000 / gridSize);
                
                for (let i = Math.max(0, latIdx - cellRadius); i < Math.min(latCells, latIdx + cellRadius); i++) {
                    for (let j = Math.max(0, lngIdx - cellRadius); j < Math.min(lngCells, lngIdx + cellRadius); j++) {
                        const lat = bounds.minLat + i * gridSize;
                        const lng = bounds.minLng + j * gridSize;
                        
                        const distance = getDistance([lat, lng], point.coords);
                        if (distance < point.radius / 1000) {
                            grid[i][j] = (point.name.includes("High Crime") && document.getElementById('area1').checked) ? Infinity : 10; // Block high crime if checked
                        }
                    }
                }
            });
            
            function toGridIndices(coords) {
                const latIdx = Math.floor((coords[0] - bounds.minLat) / gridSize);
                const lngIdx = Math.floor((coords[1] - bounds.minLng) / gridSize);
                return {
                    lat: Math.max(0, Math.min(latCells - 1, latIdx)),
                    lng: Math.max(0, Math.min(lngCells - 1, lngIdx))
                };
            }
            
            function toLatLng(indices) {
                return [
                    bounds.minLat + indices.lat * gridSize,
                    bounds.minLng + indices.lng * gridSize
                ];
            }
            
            const startPos = toGridIndices(start);
            const endPos = toGridIndices(end);
            
            const openSet = new Map();
            const closedSet = new Set();
            
            function posKey(pos) {
                return ${pos.lat},${pos.lng};
            }
            
            const travelMode = document.getElementById('travelMode').value;
            const speed = { car: 40, walk: 5, bike: 15 }; // km/h
            
            openSet.set(posKey(startPos), {
                pos: startPos,
                g: 0, // Time in minutes
                h: getDistance(toLatLng(startPos), end) / speed[travelMode] * 60,
                f: getDistance(toLatLng(startPos), end) / speed[travelMode] * 60,
                parent: null
            });
            
            const directions = [
                { lat: -1, lng: -1 }, { lat: -1, lng: 0 }, { lat: -1, lng: 1 },
                { lat: 0, lng: -1 },                       { lat: 0, lng: 1 },
                { lat: 1, lng: -1 },  { lat: 1, lng: 0 },  { lat: 1, lng: 1 }
            ];
            
            let path = [];
            let finalNode = null;
            
            while (openSet.size > 0) {
                let currentKey = null;
                let current = null;
                let lowestF = Infinity;
                
                for (const [key, node] of openSet.entries()) {
                    if (node.f < lowestF) {
                        lowestF = node.f;
                        currentKey = key;
                        current = node;
                    }
                }
                
                openSet.delete(currentKey);
                closedSet.add(currentKey);
                
                if (current.pos.lat === endPos.lat && current.pos.lng === endPos.lng) {
                    finalNode = current;
                    break;
                }
                
                for (const dir of directions) {
                    const neighbor = {
                        lat: current.pos.lat + dir.lat,
                        lng: current.pos.lng + dir.lng
                    };
                    
                    if (neighbor.lat < 0 || neighbor.lat >= latCells || 
                        neighbor.lng < 0 || neighbor.lng >= lngCells) {
                        continue;
                    }
                    
                    const neighborKey = posKey(neighbor);
                    
                    if (closedSet.has(neighborKey) || grid[neighbor.lat][neighbor.lng] === Infinity) {
                        continue;
                    }
                    
                    const neighborPos = toLatLng(neighbor);
                    const distance = getDistance(toLatLng(current.pos), neighborPos);
                    const timeCost = (distance / speed[travelMode]) * 60 * grid[neighbor.lat][neighbor.lng];
                    const g = current.g + timeCost;
                    
                    const existingNeighbor = openSet.get(neighborKey);
                    if (!existingNeighbor || g < existingNeighbor.g) {
                        const h = getDistance(neighborPos, end) / speed[travelMode] * 60;
                        openSet.set(neighborKey, {
                            pos: neighbor,
                            g: g,
                            h: h,
                            f: g + h,
                            parent: current
                        });
                    }
                }
            }
            
            if (finalNode) {
                let current = finalNode;
                while (current) {
                    path.unshift(toLatLng(current.pos));
                    current = current.parent;
                }
            }
            
            return path;
        }
        
        // Function to calculate waypoints for secure route
        function calculateSecureWaypoints(start, end) {
            const secureWaypoints = [];
            const safeAreas = [];
            for (const category in chennaiLocations) {
                for (const location in chennaiLocations[category]) {
                    const coords = chennaiLocations[category][location];
                    let isSafe = true;
                    
                    if (document.getElementById('area1').checked) {
                        for (const area of dangerAreas.highCrime) {
                            if (getDistance(coords, area.coords) < area.radius / 1000) {
                                isSafe = false;
                                break;
                            }
                        }
                    }
                    
                    if (isSafe && document.getElementById('area2').checked) {
                        for (const area of dangerAreas.floodProne) {
                            if (getDistance(coords, area.coords) < area.radius / 1000) {
                                isSafe = false;
                                break;
                            }
                        }
                    }
                    
                    if (isSafe && document.getElementById('area3').checked) {
                        for (const area of dangerAreas.heavyTraffic) {
                            if (getDistance(coords, area.coords) < area.radius / 1000) {
                                isSafe = false;
                                break;
                            }
                        }
                    }
                    
                    if (isSafe) safeAreas.push(location);
                }
            }
            
            const distancesFromStart = safeAreas.map(area => {
                const areaCoords = getCoordinates(area);
                return {
                    name: area,
                    coords: areaCoords,
                    distanceFromStart: getDistance(start, areaCoords),
                    distanceToEnd: getDistance(areaCoords, end)
                };
            });
            
            distancesFromStart.sort((a, b) => {
                const totalDistA = a.distanceFromStart + a.distanceToEnd;
                const totalDistB = b.distanceFromStart + b.distanceToEnd;
                return totalDistA - totalDistB;
            });
            
            const directDistance = getDistance(start, end);
            let numWaypoints = 1;
            if (directDistance > 10) numWaypoints = 3;
            else if (directDistance > 5) numWaypoints = 2;
            
            for (let i = 0; i < numWaypoints && i < distancesFromStart.length; i++) {
                secureWaypoints.push(distancesFromStart[i].coords);
            }
            
            return secureWaypoints;
        }
        
        // Fetch weather information
        async function updateWeatherInfo() {
            try {
                const response = await fetch('https://api.openweathermap.org/data/2.5/weather?q=Chennai&appid=YOUR_API_KEY&units=metric');
                const data = await response.json();
                document.getElementById('weatherInfo').innerHTML = 
                    Weather: ${data.weather[0].description}, Temp: ${data.main.temp}°C;
            } catch (error) {
                document.getElementById('weatherInfo').innerHTML = 'Weather info unavailable';
            }
        }
        updateWeatherInfo();
        
        // Find shortest route using A*
        function findShortestRoute() {
            const startLocation = document.getElementById('start').value;
            const endLocation = document.getElementById('end').value;
            const travelMode = document.getElementById('travelMode').value;
            
            const startCoords = getCoordinates(startLocation);
            const endCoords = getCoordinates(endLocation);
            
            const dangerPoints = [];
            if (document.getElementById('area1').checked) dangerPoints.push(...dangerAreas.highCrime);
            if (document.getElementById('area2').checked) dangerPoints.push(...dangerAreas.floodProne);
            if (document.getElementById('area3').checked) dangerPoints.push(...dangerAreas.heavyTraffic);
            
            const path = aStarAlgorithm(startCoords, endCoords, dangerPoints);
            
            if (shortestRouteControl) {
                map.removeControl(shortestRouteControl);
            }
            
            const waypoints = path.map(coord => L.latLng(coord[0], coord[1]));
            
            shortestRouteControl = L.Routing.control({
                waypoints: waypoints,
                routeWhileDragging: false,
                lineOptions: {
                    styles: [{ color: '#0078A8', weight: 6 }]
                },
                createMarker: function(i, wp, n) {
                    if (i === 0 || i === n - 1) {
                        return L.marker(wp.latLng, {
                            icon: L.icon({
                                iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon.png',
                                iconSize: [25, 41],
                                iconAnchor: [12, 41],
                                popupAnchor: [1, -34],
                                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
                                shadowSize: [41, 41]
                            })
                        }).bindPopup(i === 0 ? startLocation : endLocation);
                    }
                    return null;
                }
            }).addTo(map);
            
            shortestRouteControl.on('routesfound', function(e) {
                const route = e.routes[0];
                const distance = (route.summary.totalDistance / 1000).toFixed(2);
                const time = Math.round(route.summary.totalTime / 60);
                document.getElementById('routeInfo').innerHTML = 
                    Shortest Route (A*): ${distance} km, ${time} minutes (${travelMode});
            });
        }
        
        // Find secure route
        function findSecureRoute() {
            const startLocation = document.getElementById('start').value;
            const endLocation = document.getElementById('end').value;
            const travelMode = document.getElementById('travelMode').value;
            
            const startCoords = getCoordinates(startLocation);
            const endCoords = getCoordinates(endLocation);
            
            if (secureRouteControl) {
                map.removeControl(secureRouteControl);
            }
            
            const secureWaypoints = calculateSecureWaypoints(startCoords, endCoords);
            const waypoints = [
                L.latLng(startCoords),
                ...secureWaypoints.map(coord => L.latLng(coord)),
                L.latLng(endCoords)
            ];
            
            secureRouteControl = L.Routing.control({
                waypoints: waypoints,
                routeWhileDragging: false,
                lineOptions: {
                    styles: [{ color: '#4CAF50', weight: 6 }]
                },
                createMarker: function(i, wp, n) {
                    if (i === 0 || i === n - 1) {
                        return L.marker(wp.latLng, {
                            icon: L.icon({
                                iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-icon.png',
                                iconSize: [25, 41],
                                iconAnchor: [12, 41],
                                popupAnchor: [1, -34],
                                shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/images/marker-shadow.png',
                                shadowSize: [41, 41]
                            })
                        }).bindPopup(i === 0 ? startLocation : endLocation);
                    }
                    return null;
                }
            }).addTo(map);
            
            secureRouteControl.on('routesfound', function(e) {
                const route = e.routes[0];
                const distance = (route.summary.totalDistance / 1000).toFixed(2);
                const time = Math.round(route.summary.totalTime / 60);
                document.getElementById('routeInfo').innerHTML = 
                    Secure Route: ${distance} km, ${time} minutes (${travelMode});
            });
        }
        
        // Toggle traffic layer
        function toggleTraffic() {
            if (trafficVisible) {
                map.removeLayer(trafficLayer);
                trafficVisible = false;
            } else {
                map.addLayer(trafficLayer);
                trafficVisible = true;
            }
        }
        
        // Export route as GeoJSON
        function exportRoute() {
            const activeControl = shortestRouteControl || secureRouteControl;
            if (!activeControl) {
                alert('Please generate a route first!');
                return;
            }
            
            const route = activeControl.getPlan().getWaypoints();
            const geojson = {
                type: "FeatureCollection",
                features: [{
                    type: "Feature",
                    geometry: {
                        type: "LineString",
                        coordinates: route.map(wp => [wp.latLng.lng, wp.latLng.lat])
                    },
                    properties: {
                        name: shortestRouteControl ? "Shortest Route" : "Secure Route",
                        travelMode: document.getElementById('travelMode').value
                    }
                }]
            };
            
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(geojson));
            const downloadAnchor = document.createElement('a');
            downloadAnchor.setAttribute("href", dataStr);
            downloadAnchor.setAttribute("download", "route.geojson");
            downloadAnchor.click();
        }
        
        // Clear routes
        function clearRoutes() {
            if (shortestRouteControl) {
                map.removeControl(shortestRouteControl);
                shortestRouteControl = null;
            }
            if (secureRouteControl) {
                map.removeControl(secureRouteControl);
                secureRouteControl = null;
            }
            document.getElementById('routeInfo').innerHTML = 
                'Select start and end locations, then click a button to find a route.';
        }
        
        // Event listeners
        document.getElementById('findShortest').addEventListener('click', findShortestRoute);
        document.getElementById('findSecure').addEventListener('click', findSecureRoute);
        document.getElementById('toggleTraffic').addEventListener('click', toggleTraffic);
        document.getElementById('exportRoute').addEventListener('click', exportRoute);
        document.getElementById('clearRoutes').addEventListener('click', clearRoutes);
    </script>
</body>
</html>
